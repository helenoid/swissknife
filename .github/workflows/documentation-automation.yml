name: ðŸ“¸ SwissKnife Documentation Automation

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'web/**'
      - 'src/**'
      - 'docs/**'
  pull_request:
    branches: [ main ]
    paths:
      - 'web/**'
      - 'src/**'
  workflow_dispatch:
    inputs:
      force_update:
        description: 'Force update all screenshots'
        required: false
        default: 'false'
      skip_screenshots:
        description: 'Skip screenshot capture (docs only)'
        required: false
        default: 'false'
      notification_level:
        description: 'Notification level (none/errors/all)'
        required: false
        default: 'errors'
  schedule:
    - cron: '0 2 * * 0'  # Weekly on Sunday at 2 AM UTC

env:
  NODE_ENV: ci
  DOCUMENTATION_MODE: enhanced
  QUALITY_THRESHOLD: 70

jobs:
  documentation-generation:
    runs-on: ubuntu-latest
    
    outputs:
      quality-score: ${{ steps.quality-check.outputs.score }}
      performance-grade: ${{ steps.performance-check.outputs.grade }}
      changes-detected: ${{ steps.change-detection.outputs.changes }}
      
    steps:
      - name: ðŸ“¥ Checkout Repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: ðŸŸ¢ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: ðŸ“¦ Install Dependencies
        id: install-deps
        run: |
          echo "ðŸ“¦ Installing dependencies..."
          npm install --legacy-peer-deps
          echo "status=success" >> $GITHUB_OUTPUT
        continue-on-error: true

      - name: ðŸš¨ Dependency Installation Failed
        if: steps.install-deps.outputs.status != 'success'
        run: |
          echo "âŒ Dependency installation failed, attempting fallback..."
          npm ci --legacy-peer-deps || npm install --force
          
      - name: ðŸŽ­ Install Playwright Browsers
        id: install-playwright
        if: github.event.inputs.skip_screenshots != 'true'
        run: |
          echo "ðŸŽ­ Installing Playwright browsers..."
          npx playwright install chromium --with-deps
          echo "status=success" >> $GITHUB_OUTPUT
        continue-on-error: true
        env:
          PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: false

      - name: ðŸ–¥ï¸ Start Virtual Display
        if: github.event.inputs.skip_screenshots != 'true' && steps.install-playwright.outputs.status == 'success'
        run: |
          echo "ðŸ–¥ï¸ Setting up virtual display..."
          sudo apt-get update -qq
          sudo apt-get install -y xvfb
          export DISPLAY=:99
          Xvfb :99 -screen 0 1280x720x24 > /dev/null 2>&1 &
          echo "DISPLAY=:99" >> $GITHUB_ENV

      - name: ðŸš€ Start Web Desktop  
        id: start-desktop
        if: github.event.inputs.skip_screenshots != 'true' && steps.install-playwright.outputs.status == 'success'
        run: |
          echo "ðŸš€ Starting SwissKnife web desktop..."
          npm run webgui > server.log 2>&1 &
          
          # Advanced server readiness check
          echo "â³ Waiting for desktop server to be ready..."
          for i in {1..60}; do
            if curl -s -f http://localhost:3001/health > /dev/null 2>&1; then
              echo "âœ… Desktop server ready on port 3001"
              echo "port=3001" >> $GITHUB_OUTPUT
              echo "status=success" >> $GITHUB_OUTPUT
              break
            elif curl -s -f http://localhost:3002/health > /dev/null 2>&1; then
              echo "âœ… Desktop server ready on port 3002"
              echo "port=3002" >> $GITHUB_OUTPUT
              echo "status=success" >> $GITHUB_OUTPUT
              break
            elif curl -s http://localhost:3001 > /dev/null 2>&1; then
              echo "âœ… Desktop server ready on port 3001 (no health endpoint)"
              echo "port=3001" >> $GITHUB_OUTPUT
              echo "status=success" >> $GITHUB_OUTPUT
              break
            elif curl -s http://localhost:3002 > /dev/null 2>&1; then
              echo "âœ… Desktop server ready on port 3002 (no health endpoint)"
              echo "port=3002" >> $GITHUB_OUTPUT
              echo "status=success" >> $GITHUB_OUTPUT
              break
            fi
            echo "â³ Waiting for desktop server... ($i/60)"
            sleep 3
          done
          
          if [[ "${{ steps.start-desktop.outputs.status }}" != "success" ]]; then
            echo "âŒ Desktop server failed to start within timeout"
            echo "ðŸ“‹ Server logs:"
            cat server.log || echo "No server logs available"
            echo "status=failed" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true

      - name: ðŸ“¸ Run Enhanced Screenshot Automation
        id: screenshot-capture
        if: github.event.inputs.skip_screenshots != 'true' && steps.start-desktop.outputs.status == 'success'
        run: |
          echo "ðŸ“¸ Starting enhanced screenshot capture..."
          
          # Update configuration for detected port
          if [[ "${{ steps.start-desktop.outputs.port }}" == "3002" ]]; then
            echo "ðŸ”§ Configuring for port 3002..."
            sed -i 's/localhost:3001/localhost:3002/g' scripts/automation/update-screenshots.js
            sed -i 's/baseURL.*3001/baseURL: "http:\/\/localhost:3002"/g' playwright.config.ts
          fi
          
          # Run screenshot automation with enhanced error handling
          timeout 900 npx playwright test test/e2e/desktop-applications-documentation.test.ts --project=chromium --reporter=json:test-results/screenshot-results.json || echo "Screenshots completed with warnings"
          
          echo "ðŸ“Š Screenshot capture summary:"
          if [ -f "test-results/screenshot-results.json" ]; then
            node -e "
              const results = require('./test-results/screenshot-results.json');
              const passed = results.suites?.[0]?.tests?.filter(t => t.outcome === 'passed').length || 0;
              const failed = results.suites?.[0]?.tests?.filter(t => t.outcome === 'failed').length || 0;
              console.log(\`âœ… Passed: \${passed}, âŒ Failed: \${failed}\`);
              console.log(\`screenshots_passed=\${passed}\` >> process.env.GITHUB_OUTPUT);
              console.log(\`screenshots_failed=\${failed}\` >> process.env.GITHUB_OUTPUT);
            " 2>/dev/null || echo "Could not parse test results"
          fi
          
          echo "status=completed" >> $GITHUB_OUTPUT
        continue-on-error: true

      - name: ðŸ“ Generate Enhanced Documentation
        id: generate-docs
        run: |
          echo "ðŸ“ Generating enhanced documentation with analytics..."
          
          # Always run documentation generation (with or without screenshots)
          npm run docs:generate-only
          
          echo "âœ… Documentation generation completed"
          echo "status=success" >> $GITHUB_OUTPUT
        continue-on-error: true

      - name: ðŸ“Š Extract Quality Metrics
        id: quality-check
        if: steps.generate-docs.outputs.status == 'success'
        run: |
          echo "ðŸ“Š Extracting quality metrics..."
          
          # Extract quality score from analytics data
          if [ -f "docs/automation/analytics-data.json" ]; then
            quality_score=$(node -e "
              const data = require('./docs/automation/analytics-data.json');
              const latest = data[data.length - 1];
              console.log(latest?.quality?.overallScore || 0);
            " 2>/dev/null || echo "0")
            
            echo "ðŸ“Š Quality Score: ${quality_score}/100"
            echo "score=${quality_score}" >> $GITHUB_OUTPUT
            
            # Determine quality grade
            if [ "${quality_score}" -ge 90 ]; then
              echo "grade=A" >> $GITHUB_OUTPUT
              echo "grade_emoji=ðŸ†" >> $GITHUB_OUTPUT
            elif [ "${quality_score}" -ge 80 ]; then
              echo "grade=B" >> $GITHUB_OUTPUT  
              echo "grade_emoji=âœ…" >> $GITHUB_OUTPUT
            elif [ "${quality_score}" -ge 70 ]; then
              echo "grade=C" >> $GITHUB_OUTPUT
              echo "grade_emoji=âš ï¸" >> $GITHUB_OUTPUT
            else
              echo "grade=F" >> $GITHUB_OUTPUT
              echo "grade_emoji=âŒ" >> $GITHUB_OUTPUT
            fi
          else
            echo "score=0" >> $GITHUB_OUTPUT
            echo "grade=Unknown" >> $GITHUB_OUTPUT
            echo "grade_emoji=â“" >> $GITHUB_OUTPUT
          fi

      - name: âš¡ Extract Performance Metrics
        id: performance-check
        if: steps.generate-docs.outputs.status == 'success'
        run: |
          echo "âš¡ Extracting performance metrics..."
          
          if [ -f "docs/automation/performance-metrics.json" ]; then
            node -e "
              const data = require('./docs/automation/performance-metrics.json');
              const latest = data[data.length - 1];
              
              console.log(\`generation_time=\${latest?.documentation?.generationTime || 0}\` >> process.env.GITHUB_OUTPUT);
              console.log(\`memory_usage=\${Math.round((latest?.performance?.memoryUsage?.heapUsed || 0) / 1024 / 1024)}\` >> process.env.GITHUB_OUTPUT);
              console.log(\`total_files=\${latest?.documentation?.filesGenerated || 0}\` >> process.env.GITHUB_OUTPUT);
              
              // Performance grade based on benchmarks
              const genTime = latest?.documentation?.generationTime || 0;
              const memUsage = (latest?.performance?.memoryUsage?.heapUsed || 0) / 1024 / 1024;
              
              let grade = 'A';
              if (genTime > 5000 || memUsage > 100) grade = 'B';
              if (genTime > 10000 || memUsage > 200) grade = 'C';
              if (genTime > 20000 || memUsage > 500) grade = 'F';
              
              console.log(\`grade=\${grade}\` >> process.env.GITHUB_OUTPUT);
            " 2>/dev/null || echo "Could not extract performance metrics"
          fi

      - name: ðŸ” Advanced Change Detection
        id: change-detection
        run: |
          echo "ðŸ” Analyzing documentation changes..."
          
          # Check for any changes in docs directory
          if git diff --quiet docs/; then
            echo "changes=false" >> $GITHUB_OUTPUT
            echo "change_type=none" >> $GITHUB_OUTPUT
            echo "files_changed=0" >> $GITHUB_OUTPUT
          else
            echo "changes=true" >> $GITHUB_OUTPUT
            
            # Count changed files
            files_changed=$(git diff --name-only docs/ | wc -l)
            echo "files_changed=${files_changed}" >> $GITHUB_OUTPUT
            
            # Determine change type
            if git diff --name-only docs/ | grep -q "screenshots/"; then
              if git diff --name-only docs/ | grep -q "\.md$"; then
                echo "change_type=both" >> $GITHUB_OUTPUT
              else
                echo "change_type=screenshots" >> $GITHUB_OUTPUT
              fi
            else
              echo "change_type=documentation" >> $GITHUB_OUTPUT
            fi
            
            echo "ðŸ“‹ Files changed:"
            git diff --name-only docs/ | head -10
            if [ "${files_changed}" -gt 10 ]; then
              echo "... and $((files_changed - 10)) more files"
            fi
            
            echo ""
            echo "ðŸ“ˆ Change statistics:"
            git diff --stat docs/
          fi

      - name: ðŸ“Š Generate Change Summary
        id: change-summary
        if: steps.change-detection.outputs.changes == 'true'
        run: |
          echo "ðŸ“Š Generating comprehensive change summary..."
          
          # Create detailed change summary
          cat > change-summary.md << 'EOF'
          # ðŸ“¸ Documentation Update Summary
          
          **Generated**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          **Workflow**: ${{ github.workflow }}
          **Trigger**: ${{ github.event_name }}
          
          ## ðŸ“Š Quality Metrics
          - **Quality Score**: ${{ steps.quality-check.outputs.score }}/100 ${{ steps.quality-check.outputs.grade_emoji }}
          - **Performance**: ${{ steps.performance-check.outputs.grade }} (${{ steps.performance-check.outputs.generation_time }}ms, ${{ steps.performance-check.outputs.memory_usage }}MB)
          - **Files Updated**: ${{ steps.change-detection.outputs.files_changed }}
          - **Change Type**: ${{ steps.change-detection.outputs.change_type }}
          
          ## ðŸ”„ Changes Made
          EOF
          
          echo "" >> change-summary.md
          echo '```' >> change-summary.md
          git diff --stat docs/ >> change-summary.md
          echo '```' >> change-summary.md
          
          echo "summary_created=true" >> $GITHUB_OUTPUT

      - name: âœ… Commit Documentation Updates
        id: commit-changes
        if: steps.change-detection.outputs.changes == 'true'
        run: |
          echo "âœ… Committing documentation updates..."
          
          # Configure git
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          # Add all documentation changes
          git add docs/
          
          # Create comprehensive commit message
          commit_msg="ðŸ“¸ Auto-update documentation - Quality: ${{ steps.quality-check.outputs.score }}/100 ${{ steps.quality-check.outputs.grade_emoji }}

          - Files updated: ${{ steps.change-detection.outputs.files_changed }}
          - Change type: ${{ steps.change-detection.outputs.change_type }}
          - Performance: ${{ steps.performance-check.outputs.grade }} grade
          - Generation time: ${{ steps.performance-check.outputs.generation_time }}ms
          - Memory usage: ${{ steps.performance-check.outputs.memory_usage }}MB
          
          Automated by: ${{ github.workflow }} (${{ github.event_name }})"
          
          git commit -m "${commit_msg}" || echo "No changes to commit"
          echo "status=success" >> $GITHUB_OUTPUT

      - name: ðŸš€ Push Changes
        if: steps.commit-changes.outputs.status == 'success'
        uses: ad-m/github-push-action@master
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          branch: ${{ github.ref }}

      - name: ðŸ“Š Upload Performance Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: documentation-reports-${{ github.run_number }}
          path: |
            docs/automation/performance-report.md
            docs/automation/quality-report.md
            docs/automation/performance-metrics.json
            docs/automation/analytics-data.json
            test-results/
            change-summary.md
          retention-days: 30

      - name: ðŸš¨ Quality Threshold Check
        id: quality-gate
        if: steps.quality-check.outputs.score != '' && steps.quality-check.outputs.score < env.QUALITY_THRESHOLD
        run: |
          echo "âš ï¸ Documentation quality below threshold!"
          echo "Current: ${{ steps.quality-check.outputs.score }}/100"
          echo "Threshold: ${QUALITY_THRESHOLD}/100"
          echo "failed=true" >> $GITHUB_OUTPUT
          
          # Create quality improvement issue (if needed)
          if [ "${{ github.event.inputs.notification_level }}" != "none" ]; then
            echo "ðŸ“‹ Quality improvement needed - see reports for details"
          fi

      - name: ðŸ’¬ Success Notification
        if: steps.change-detection.outputs.changes == 'true' && steps.quality-gate.outputs.failed != 'true' && github.event.inputs.notification_level == 'all'
        run: |
          echo "ðŸŽ‰ Documentation successfully updated!"
          echo "ðŸ“Š Quality Score: ${{ steps.quality-check.outputs.score }}/100 ${{ steps.quality-check.outputs.grade_emoji }}"
          echo "âš¡ Performance: ${{ steps.performance-check.outputs.grade }} grade"
          echo "ðŸ“ Files Updated: ${{ steps.change-detection.outputs.files_changed }}"

      - name: ðŸš¨ Failure Notification  
        if: failure() && github.event.inputs.notification_level != 'none'
        run: |
          echo "âŒ Documentation automation failed!"
          echo "ðŸ” Check the workflow logs for details"
          echo "ðŸ“Š Partial results may be available in artifacts"

      - name: ðŸ“‹ Workflow Summary
        if: always()
        run: |
          echo "## ðŸ“¸ SwissKnife Documentation Automation Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status**: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "**Quality Score**: ${{ steps.quality-check.outputs.score || 'N/A' }}/100 ${{ steps.quality-check.outputs.grade_emoji || '' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Performance Grade**: ${{ steps.performance-check.outputs.grade || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Files Changed**: ${{ steps.change-detection.outputs.files_changed || '0' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Screenshots**: ${{ steps.screenshot-capture.outputs.screenshots_passed || '0' }} passed, ${{ steps.screenshot-capture.outputs.screenshots_failed || '0' }} failed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ“Š **Reports Available**:" >> $GITHUB_STEP_SUMMARY
          echo "- Performance Report: \`docs/automation/performance-report.md\`" >> $GITHUB_STEP_SUMMARY
          echo "- Quality Report: \`docs/automation/quality-report.md\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.quality-gate.outputs.failed }}" == "true" ]; then
            echo "âš ï¸ **Quality Alert**: Documentation quality below threshold (${{ env.QUALITY_THRESHOLD }}/100)" >> $GITHUB_STEP_SUMMARY
          fi

      - name: ðŸŽ¯ Set Job Outputs
        if: always()
        run: |
          echo "quality-score=${{ steps.quality-check.outputs.score || '0' }}" >> $GITHUB_OUTPUT
          echo "performance-grade=${{ steps.performance-check.outputs.grade || 'Unknown' }}" >> $GITHUB_OUTPUT  
          echo "changes-detected=${{ steps.change-detection.outputs.changes || 'false' }}" >> $GITHUB_OUTPUT

      - name: ðŸ’¾ Commit Updated Documentation
        if: steps.check_changes.outputs.changes == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "SwissKnife Automation"
          git add docs/
          git commit -m "ðŸ“¸ Update application screenshots and documentation

          - Automated screenshot capture via Playwright
          - Updated application documentation
          - Refreshed backend dependencies mapping
          - Generated features matrix
          
          ðŸ¤– This is an automated update from GitHub Actions"

      - name: ðŸš€ Push Changes
        if: steps.check_changes.outputs.changes == 'true'
        uses: ad-m/github-push-action@master
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          branch: ${{ github.ref }}

      - name: ðŸ“ Create PR Comment (if PR)
        if: github.event_name == 'pull_request' && steps.check_changes.outputs.changes == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## ðŸ“¸ Documentation Updated

              The SwissKnife documentation has been automatically updated with new screenshots and application information.

              ### Changes Made:
              - âœ… Captured latest application screenshots
              - âœ… Updated application documentation
              - âœ… Refreshed backend dependencies mapping
              - âœ… Generated features matrix

              ### Screenshots Available:
              - Desktop Overview
              - Individual Application Windows
              - Updated Documentation Files

              The documentation is now synchronized with the latest UI changes.

              *ðŸ¤– This comment was generated automatically by the documentation automation system.*`
            })

      - name: ðŸ“¤ Upload Screenshots as Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: swissknife-screenshots
          path: |
            docs/screenshots/
            docs/applications/
          retention-days: 30

      - name: ðŸ“‹ Summary Report
        if: always()
        run: |
          echo "## ðŸ“¸ SwissKnife Documentation Automation Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸŽ¯ Automation Results" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.check_changes.outputs.changes }}" == "true" ]; then
            echo "- âœ… Documentation updated successfully" >> $GITHUB_STEP_SUMMARY
            echo "- ðŸ“¸ Screenshots captured and committed" >> $GITHUB_STEP_SUMMARY
            echo "- ðŸ“ Application documentation regenerated" >> $GITHUB_STEP_SUMMARY
          else
            echo "- â„¹ï¸ No changes detected - documentation is up to date" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“Š Documentation Files" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ  [Main Documentation](docs/applications/README.md)" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ”— [Backend Dependencies](docs/applications/backend-dependencies.md)" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ“‹ [Features Matrix](docs/applications/features-matrix.md)" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ¤– [Automation Guide](docs/automation/README.md)" >> $GITHUB_STEP_SUMMARY
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ–¼ï¸ Screenshots" >> $GITHUB_STEP_SUMMARY
          echo "All application screenshots are automatically captured and stored in \`docs/screenshots/\`" >> $GITHUB_STEP_SUMMARY
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "*ðŸ¤– Automated by SwissKnife Documentation System*" >> $GITHUB_STEP_SUMMARY